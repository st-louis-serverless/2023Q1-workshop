# Serverless Databases

These commands were used to initialize the project:
```shell
mkdir lab4-serverless-db && cd lab4-serverless-db && cdk init app --language typescript
```

## Overview


### DynamoDB

We'll create a DynamoDB database table. The goal is to show how to set up a DynamoDB table.

### Aurora Serverless

Aurora Serverless is a pay-as-you-go Aurora database, using either Postgres or MySQL compatibility.

## Labs

### Exercise 1 - DynamoDB

> A. Install dependencies (npm i), then verify the setup with `tsc && cdk synth`

> B. Deploy with `cdk deploy`. Observe the outputs. Capture the API Gateway URL.

> C. POST some data shaped like the following through the API Gateway directly into DynamoDB
> Note: You will need to use Auth. Postman will do this for you. Running an API Gateway Test execution should as well.

```json
{
  "first_name": "Fred",
  "last_name": "Flintstone",
  "message": "This is a test"
}
```

> D. Visit the DynamoDB service and examine the contents of the table. Grab one of the generated id values
> (it was generated by API Gateway as a `requestId`)

> E. Do a GET request, appending that `id` value onto the API Gateway url (after the `/dev`). Observe the
> record is fetched.

> F. Do DELETE request, appending that `id` value onto the API Gateway url (after the `/dev`). Observe the
> entire deleted record is fetched, including the `id`, but the record is now absent from the table

### Exercise 2 - Aurora Serverless

> A. We won't provision an Aurora Serverless database, but review the following example code from the 
> CDK docs to get an idea of what's involved. It provisions a ServerlessCluster and fronts it with GraphQL.
> Nice!

```typescript
// Create username and password secret for DB Cluster
const secret = new rds.DatabaseSecret(this, 'AuroraSecret', {
  username: 'clusteradmin',
});

// The VPC to place the cluster in
const vpc = new ec2.Vpc(this, 'AuroraVpc');

// Create the serverless cluster, provide all values needed to customise the database.
const cluster = new rds.ServerlessCluster(this, 'AuroraCluster', {
  engine: rds.DatabaseClusterEngine.AURORA_MYSQL,
  vpc,
  credentials: { username: 'clusteradmin' },
  clusterIdentifier: 'db-endpoint-test',
  defaultDatabaseName: 'demos',
});

// Build a data source for AppSync to access the database.
declare const api: appsync.GraphqlApi;
const rdsDS = api.addRdsDataSource('rds', cluster, secret, 'demos');

// Set up a resolver for an RDS query.
rdsDS.createResolver('QueryGetDemosRdsResolver', {
  typeName: 'Query',
  fieldName: 'getDemosRds',
  requestMappingTemplate: appsync.MappingTemplate.fromString(`
  {
    "version": "2018-05-29",
    "statements": [
      "SELECT * FROM demos"
    ]
  }
  `),
  responseMappingTemplate: appsync.MappingTemplate.fromString(`
    $utils.toJson($utils.rds.toJsonObject($ctx.result)[0])
  `),
});

// Set up a resolver for an RDS mutation.
rdsDS.createResolver('MutationAddDemoRdsResolver', {
  typeName: 'Mutation',
  fieldName: 'addDemoRds',
  requestMappingTemplate: appsync.MappingTemplate.fromString(`
  {
    "version": "2018-05-29",
    "statements": [
      "INSERT INTO demos VALUES (:id, :version)",
      "SELECT * WHERE id = :id"
    ],
    "variableMap": {
      ":id": $util.toJson($util.autoId()),
      ":version": $util.toJson($ctx.args.version)
    }
  }
  `),
  responseMappingTemplate: appsync.MappingTemplate.fromString(`
    $utils.toJson($utils.rds.toJsonObject($ctx.result)[1][0])
  `),
});
```
